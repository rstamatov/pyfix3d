"use strict";(self.webpackChunkk3d=self.webpackChunkk3d||[]).push([[987],{4987:(t,e,n)=>{n.r(e),n.d(e,{AVERAGE:()=>r,CENTER:()=>s,CONTAINED:()=>u,INTERSECTED:()=>c,MeshBVH:()=>dt,MeshBVHDebug:()=>Mt,MeshBVHVisualizer:()=>gt,NOT_INTERSECTED:()=>a,SAH:()=>i,Visualizer:()=>gt,acceleratedRaycast:()=>zt,computeBoundsTree:()=>Dt,disposeBoundsTree:()=>vt,estimateMemoryInBytes:()=>Bt,getBVHExtremes:()=>bt});var o=n(669);const s=0,r=1,i=2,a=0,c=1,u=2;class l{constructor(){}}function f(t,e){return e.min.x=t[0],e.min.y=t[1],e.min.z=t[2],e.max.x=t[3],e.max.y=t[4],e.max.z=t[5],e}function d(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const s=t[o+3]-t[o];s>n&&(n=s,e=o)}return e}const h=Math.pow(2,-24),p=["x","y","z"],x=new o.Box3;function m(t,e,n,o,s=null){let r=1/0,i=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,f=1/0,d=1/0,h=1/0,p=-1/0,x=-1/0,m=-1/0;const y=null!==s;for(let o=6*e,s=6*(e+n);o<s;o+=6){const e=t[o+0],n=t[o+1],s=e-n,g=e+n;s<r&&(r=s),g>c&&(c=g),y&&e<f&&(f=e),y&&e>p&&(p=e);const w=t[o+2],b=t[o+3],B=w-b,T=w+b;B<i&&(i=B),T>u&&(u=T),y&&w<d&&(d=w),y&&w>x&&(x=w);const P=t[o+4],A=t[o+5],M=P-A,V=P+A;M<a&&(a=M),V>l&&(l=V),y&&P<h&&(h=P),y&&P>m&&(m=P)}o[0]=r,o[1]=i,o[2]=a,o[3]=c,o[4]=u,o[5]=l,y&&(s[0]=f,s[1]=d,s[2]=h,s[3]=p,s[4]=x,s[5]=m)}function y(t,e,n,o){let s=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,u=-1/0;for(let o=6*e,l=6*(e+n);o<l;o+=6){const e=t[o+0];e<s&&(s=e),e>a&&(a=e);const n=t[o+2];n<r&&(r=n),n>c&&(c=n);const l=t[o+4];l<i&&(i=l),l>u&&(u=l)}o[0]=s,o[1]=r,o[2]=i,o[3]=a,o[4]=c,o[5]=u}class g{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let s=0,r=t.length;s<r;s++){const r=t[s][e];n=Math.min(r,n),o=Math.max(r,o)}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let s=0,r=e.length;s<r;s++){const r=e[s],i=t.dot(r);n=Math.min(i,n),o=Math.max(i,o)}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}g.prototype.setFromBox=function(){const t=new o.Vector3;return function(e,n){const o=n.min,s=n.max;let r=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=o.x*n+s.x*(1-n),t.y=o.y*a+s.y*(1-a),t.z=o.z*c+s.z*(1-c);const u=e.dot(t);r=Math.min(u,r),i=Math.max(u,i)}this.min=r,this.max=i}}(),new g;const w=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Vector3;return function(o,s,r){const i=o.start,a=t,c=s.start,u=e;n.subVectors(i,c),t.subVectors(o.end,s.start),e.subVectors(s.end,s.start);const l=n.dot(u),f=u.dot(a),d=u.dot(u),h=n.dot(a),p=a.dot(a)*d-f*f;let x,m;x=0!==p?(l*f-h*d)/p:0,m=(l+x*f)/d,r.x=x,r.y=m}}(),b=function(){const t=new o.Vector2,e=new o.Vector3,n=new o.Vector3;return function(o,s,r,i){w(o,s,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return o.at(a,r),void s.at(c,i);if(a>=0&&a<=1)return c<0?s.at(0,i):s.at(1,i),void o.closestPointToPoint(i,!0,r);if(c>=0&&c<=1)return a<0?o.at(0,r):o.at(1,r),void s.closestPointToPoint(r,!0,i);{let t,u;t=a<0?o.start:o.end,u=c<0?s.start:s.end;const l=e,f=n;return o.closestPointToPoint(u,!0,e),s.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=f.distanceToSquared(t)?(r.copy(l),void i.copy(u)):(r.copy(t),void i.copy(f))}}}(),B=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Plane,s=new o.Line3;return function(o,r){const{radius:i,center:a}=o,{a:c,b:u,c:l}=r;if(s.start=c,s.end=u,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(s.start=c,s.end=l,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(s.start=u,s.end=l,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const f=r.getPlane(n);if(Math.abs(f.distanceToPoint(a))<=i){const t=f.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();class T extends o.Triangle{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new o.Vector3)),this.satBounds=new Array(4).fill().map((()=>new g)),this.points=[this.a,this.b,this.c],this.sphere=new o.Sphere,this.needsUpdate=!1}intersectsSphere(t){return B(t,this)}}T.prototype.update=function(){const t=new Array(3);return function(){const e=this.a,n=this.b,o=this.c;t[0]=this.a,t[1]=this.b,t[2]=this.c;const s=this.satAxes,r=this.satBounds,i=s[0],a=r[0];this.getNormal(i),a.setFromPoints(i,t);const c=s[1],u=r[1];c.subVectors(e,n),u.setFromPoints(c,t);const l=s[2],f=r[2];l.subVectors(n,o),f.setFromPoints(l,t);const d=s[3],h=r[3];d.subVectors(o,e),h.setFromPoints(d,t),this.sphere.setFromPoints(this.points),this.needsUpdate=!1}}(),T.prototype.closestPointToSegment=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Line3;return function(o,s=null,r=null){this.needsUpdate&&this.update();const{start:i,end:a}=o,c=this.points;let u,l=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;n.start.copy(c[i]),n.end.copy(c[a]),b(n,o,t,e),u=t.distanceToSquared(e),u<l&&(l=u,s&&s.copy(t),r&&r.copy(e))}return this.closestPointToPoint(i,t),u=i.distanceToSquared(t),u<l&&(l=u,s&&s.copy(t),r&&r.copy(i)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,s&&s.copy(t),r&&r.copy(a)),Math.sqrt(l)}}(),T.prototype.intersectsTriangle=function(){const t=new T,e=new Array(3),n=new Array(3),s=new g,r=new g,i=new o.Vector3;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle||(t.copy(o),t.update(),o=t);const a=this.satBounds,c=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let t=0;t<4;t++){const e=a[t],o=c[t];if(s.setFromPoints(o,n),e.isSeparated(s))return!1}const u=o.satBounds,l=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=u[t],o=l[t];if(s.setFromPoints(o,e),n.isSeparated(s))return!1}for(let t=0;t<4;t++){const o=c[t];for(let t=0;t<4;t++){const a=l[t];if(i.crossVectors(o,a),s.setFromPoints(i,e),r.setFromPoints(i,n),s.isSeparated(r))return!1}}return!0}}(),T.prototype.distanceToPoint=function(){const t=new o.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),T.prototype.distanceToTriangle=function(){const t=new o.Vector3,e=new o.Vector3,n=["a","b","c"],s=new o.Line3,r=new o.Line3;return function(o,i=null,a=null){if(o.needsUpdate&&o.update(),this.needsUpdate&&this.update(),this.intersectsTriangle(o))return(i||a)&&(this.getMidpoint(t),o.closestPointToPoint(t,e),this.closestPointToPoint(e,t),i&&i.copy(t),a&&a.copy(e)),0;let c=1/0;for(let e=0;e<3;e++){let s;const r=n[e],u=o[r];this.closestPointToPoint(u,t),s=u.distanceToSquared(t),s<c&&(c=s,i&&i.copy(t),a&&a.copy(u));const l=this[r];o.closestPointToPoint(l,t),s=l.distanceToSquared(t),s<c&&(c=s,i&&i.copy(l),a&&a.copy(t))}for(let u=0;u<3;u++){const l=n[u],f=n[(u+1)%3];s.set(this[l],this[f]);for(let u=0;u<3;u++){const l=n[u],f=n[(u+1)%3];r.set(o[l],o[f]),b(s,r,t,e);const d=t.distanceToSquared(e);d<c&&(c=d,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(c)}}();class P extends o.Box3{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new o.Matrix4,this.invMatrix=new o.Matrix4,this.points=new Array(8).fill().map((()=>new o.Vector3)),this.satAxes=new Array(3).fill().map((()=>new o.Vector3)),this.satBounds=new Array(3).fill().map((()=>new g)),this.alignedSatBounds=new Array(3).fill().map((()=>new g)),this.sphere=new o.Sphere}set(t,e,n){super.set(t,e),this.matrix=n}copy(t){super.copy(t),this.matrix.copy(t.matrix)}}function A(t,e,n,o){const s=t.a,r=t.b,i=t.c;let a=n.getX(e);s.x=o.getX(a),s.y=o.getY(a),s.z=o.getZ(a),a=n.getX(e+1),r.x=o.getX(a),r.y=o.getY(a),r.z=o.getZ(a),a=n.getX(e+2),i.x=o.getX(a),i.y=o.getY(a),i.z=o.getZ(a)}P.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let s=0;s<=1;s++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const a=o[1*s|2*r|4*i];a.x=s?n.x:e.x,a.y=r?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}this.sphere.setFromPoints(this.points);const s=this.satBounds,r=this.satAxes,i=o[0];for(let t=0;t<3;t++){const e=r[t],n=s[t],a=o[1<<t];e.subVectors(i,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert()},P.prototype.intersectsBox=function(){const t=new g;return function(e){if(!e.intersectsSphere(this.sphere))return!1;const n=e.min,o=e.max,s=this.satBounds,r=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=r[n],i=s[n];if(t.setFromBox(o,e),i.isSeparated(t))return!1}return!0}}(),P.prototype.intersectsTriangle=function(){const t=new T,e=new Array(3),n=new g,s=new g,r=new o.Vector3;return function(o){o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const i=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const o=i[t],s=a[t];if(n.setFromPoints(s,e),o.isSeparated(n))return!1}const c=o.satBounds,u=o.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],o=u[t];if(n.setFromPoints(o,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const i=u[t];if(r.crossVectors(o,i),n.setFromPoints(r,e),s.setFromPoints(r,l),n.isSeparated(s))return!1}}return!0}}(),P.prototype.closestPointToPoint=function(t,e){return e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},P.prototype.distanceToPoint=function(){const t=new o.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),P.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new o.Line3)),n=new Array(12).fill().map((()=>new o.Line3)),s=new o.Vector3,r=new o.Vector3;return function(o,i=0,a=null,c=null){if(this.intersectsBox(o))return(a||c)&&(o.getCenter(r),this.closestPointToPoint(r,s),o.closestPointToPoint(s,r),a&&a.copy(s),c&&c.copy(r)),0;const u=i*i,l=o.min,f=o.max,d=this.points;let h=1/0;for(let t=0;t<8;t++){const e=d[t];r.copy(e).clamp(l,f);const n=e.distanceToSquared(r);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(r),n<u))return Math.sqrt(n)}let p=0;for(let o=0;o<3;o++)for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){const i=(o+1)%3,a=(o+2)%3,c=1<<o|s<<i|r<<a,u=d[s<<i|r<<a],h=d[c];e[p].set(u,h);const x=t[o],m=t[i],y=t[a],g=n[p],w=g.start,b=g.end;w[x]=l[x],w[m]=s?l[m]:f[m],w[y]=r?l[y]:f[m],b[x]=f[x],b[m]=s?l[m]:f[m],b[y]=r?l[y]:f[m],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){r.x=t?f.x:l.x,r.y=e?f.y:l.y,r.z=n?f.z:l.z,this.closestPointToPoint(r,s);const o=r.distanceToSquared(s);if(o<h&&(h=o,a&&a.copy(s),c&&c.copy(r),o<u))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=n[t];b(o,e,s,r);const i=s.distanceToSquared(r);if(i<h&&(h=i,a&&a.copy(s),c&&c.copy(r),i<u))return Math.sqrt(i)}}return Math.sqrt(h)}}();var M=new o.Vector3,V=new o.Vector3,S=new o.Vector3,F=new o.Vector2,z=new o.Vector2,D=new o.Vector2,v=new o.Vector3,_=new o.Vector3;function G(t,e,n,s,r,i){const a=3*r,c=e.index.getX(a),u=e.index.getX(a+1),l=e.index.getX(a+2),f=function(t,e,n,s,r,i,a,c){M.fromBufferAttribute(s,i),V.fromBufferAttribute(s,a),S.fromBufferAttribute(s,c);var u=function(t,e,n,s,r,i,a,c){if(null===(e.side===o.BackSide?s.intersectTriangle(a,i,r,!0,c):s.intersectTriangle(r,i,a,e.side!==o.DoubleSide,c)))return null;_.copy(c),_.applyMatrix4(t.matrixWorld);var u=n.ray.origin.distanceTo(_);return u<n.near||u>n.far?null:{distance:u,point:_.clone(),object:t}}(t,t.material,e,n,M,V,S,v);if(u){r&&(F.fromBufferAttribute(r,i),z.fromBufferAttribute(r,a),D.fromBufferAttribute(r,c),u.uv=o.Triangle.getUV(v,M,V,S,F,z,D,new o.Vector2));const t={a:i,b:a,c,normal:new o.Vector3,materialIndex:0};o.Triangle.getNormal(M,V,S,t.normal),u.face=t,u.faceIndex=i}return u}(t,n,s,e.attributes.position,e.attributes.uv,c,u,l);return f?(f.faceIndex=r,i&&i.push(f),f):null}function k(t,e,n,o,s,r,i){for(let a=s,c=s+r;a<c;a++)G(t,e,n,o,a,i)}function U(t,e,n,o,s,r){let i=1/0,a=null;for(let c=s,u=s+r;c<u;c++){const s=G(t,e,n,o,c);s&&s.distance<i&&(a=s,i=s.distance)}return a}const E=new o.Box3,I=new o.Vector3,q=["x","y","z"];function L(t,e,n){return f(t.boundingData,E),e.intersectBox(E,n)}function N(t,e,n,o,s){t.continueGeneration&&t.continueGeneration(),t.count?k(e,e.geometry,n,o,t.offset,t.count,s):(L(t.left,o,I)&&N(t.left,e,n,o,s),L(t.right,o,I)&&N(t.right,e,n,o,s))}function H(t,e,n,o){if(t.continueGeneration&&t.continueGeneration(),t.count)return U(e,e.geometry,n,o,t.offset,t.count);{const s=t.splitAxis,r=q[s],i=o.direction[r]>=0;let a,c;i?(a=t.left,c=t.right):(a=t.right,c=t.left);const u=L(a,o,I)?H(a,e,n,o):null;if(u){const t=u.point[r];if(i?t<=c.boundingData[s]:t>=c.boundingData[s+3])return u}const l=L(c,o,I)?H(c,e,n,o):null;return u&&l?u.distance<=l.distance?u:l:u||l||null}}const X=function(){const t=new T,e=new o.Box3,n=new o.Box3;function s(t,e,n,o,s,r,i){const a=n.index,c=n.attributes.position;for(let n=3*t,u=3*(e+t);n<u;n+=3)if(A(i,n,a,c),i.needsUpdate=!0,o(i,n,n+1,n+2,s,r))return!0;return!1}return function o(r,i,a,c=null,l=null,d=0,h=t,p=e,x=n){function m(t){for(t.continueGeneration&&t.continueGeneration();!t.count;)(t=t.left).continueGeneration&&t.continueGeneration();return t.offset}function y(t){for(t.continueGeneration&&t.continueGeneration();!t.count;)(t=t.right).continueGeneration&&t.continueGeneration();return t.offset+t.count}if(r.continueGeneration&&r.continueGeneration(),r.count&&c){const t=i.geometry;return s(r.offset,r.count,t,c,!1,d,h)}{const t=r.left,e=r.right;let n,g,w,b,B=t,T=e;if(l&&(w=p,b=x,f(B.boundingData,w),f(T.boundingData,b),n=l(w),g=l(b),g<n)){B=e,T=t;const o=n;n=g,g=o,w=b}w||(w=p,f(B.boundingData,w));const P=a(w,!!B.count,n,d+1);let A;if(P===u){const t=i.geometry,e=m(B);A=s(e,y(B)-e,t,c,!0,d+1,h)}else A=P&&o(B,i,a,c,l,d+1,h,p,x);if(A)return!0;b=x,f(T.boundingData,b);const M=a(b,!!T.count,g,d+1);let V;if(M===u){const t=i.geometry,e=m(T);V=s(e,y(T)-e,t,c,!0,d+1,h)}else V=M&&o(T,i,a,c,l,d+1,h,p,x);return!!V}}}(),O=function(){const t=new T,e=new T,n=new o.Mesh,s=new o.Matrix4,r=new P,i=new P;return function o(a,c,u,l,d=null){if(a.continueGeneration&&a.continueGeneration(),null===d&&(u.boundingBox||u.computeBoundingBox(),r.set(u.boundingBox.min,u.boundingBox.max,l),r.update(),d=r),!a.count){const t=a.left,e=a.right;return f(t.boundingData,E),d.intersectsBox(E)&&o(t,c,u,l,d)?!0:(f(e.boundingData,E),!(!d.intersectsBox(E)||!o(e,c,u,l,d)))}{const o=c.geometry,r=o.index,d=o.attributes.position,h=u.index,p=u.attributes.position,x=a.offset,m=a.count;if(s.copy(l).invert(),u.boundsTree){f(a.boundingData,i),i.matrix.copy(s),i.update(),n.geometry=u;const t=u.boundsTree.shapecast(n,(t=>i.intersectsBox(t)),(function(t){t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.update();for(let n=3*x,o=3*(m+x);n<o;n+=3)if(A(e,n,r,d),e.update(),t.intersectsTriangle(e))return!0;return!1}));return n.geometry=null,t}for(let n=3*x,o=m+3*x;n<o;n+=3){A(t,n,r,d),t.a.applyMatrix4(s),t.b.applyMatrix4(s),t.c.applyMatrix4(s),t.update();for(let n=0,o=h.count;n<o;n+=3)if(A(e,n,h,p),e.update(),t.intersectsTriangle(e))return!0}}}}(),C=new o.Box3,R=new o.Vector3,j=["x","y","z"];function W(t,e,n,o,s){let r=2*t,i=tt,a=et,c=nt;65535===a[r+15]?k(e,e.geometry,n,o,c[t+6],a[r+14],s):($(t+8,i,o,R)&&W(t+8,e,n,o,s),$(c[t+6],i,o,R)&&W(c[t+6],e,n,o,s))}function Y(t,e,n,o){let s=2*t,r=tt,i=et,a=nt;if(65535===i[s+15])return U(e,e.geometry,n,o,a[t+6],i[s+14]);{const s=a[t+7],i=j[s],c=o.direction[i]>=0;let u,l;c?(u=t+8,l=a[t+6]):(u=a[t+6],l=t+8);const f=$(u,r,o,R)?Y(u,e,n,o):null;if(f){const t=f.point[i];if(c?t<=r[l+s]:t>=r[l+s+3])return f}const d=$(l,r,o,R)?Y(l,e,n,o):null;return f&&d?f.distance<=d.distance?f:d:f||d||null}}const Z=function(){const t=new T,e=new o.Box3,n=new o.Box3;function s(t,e,n,o,s,r,i){const a=n.index,c=n.attributes.position;for(let n=3*t,u=3*(e+t);n<u;n+=3)if(A(i,n,a,c),i.needsUpdate=!0,o(i,n,n+1,n+2,s,r))return!0;return!1}return function o(r,i,a,c=null,l=null,f=0,d=t,h=e,p=n){function x(t){let e=2*t,n=et,o=nt;for(;65535!==n[e+15];)e=2*(t+=8);return o[t+6]}function m(t){let e=2*t,n=et,o=nt;for(;65535!==n[e+15];)e=2*(t=o[t+6]);return o[t+6]+n[e+14]}let y=2*r,g=tt,w=et,b=nt;if(65535===w[y+15]&&c){const t=i.geometry;return s(b[r+6],w[y+14],t,c,!1,f,d)}{const t=r+8,e=b[r+6];let n,y,B,T,P=t,A=e;if(l&&(B=h,T=p,rt(P,g,B),rt(A,g,T),n=l(B),y=l(T),y<n)){P=e,A=t;const o=n;n=y,y=o,B=T}B||(B=h,rt(P,g,B));const M=a(B,!(65535!==w[P+15]),n,f+1);let V;if(M===u){const t=i.geometry,e=x(P);V=s(e,m(P)-e,t,c,!0,f+1,d)}else V=M&&o(P,i,a,c,l,f+1,d,h,p);if(V)return!0;T=p,rt(A,g,T);const S=a(T,!(65535!==w[A+15]),y,f+1);let F;if(S===u){const t=i.geometry,e=x(A);F=s(e,m(A)-e,t,c,!0,f+1,d)}else F=S&&o(A,i,a,c,l,f+1,d,h,p);return!!F}}}(),J=function(){const t=new T,e=new T,n=new o.Mesh,s=new o.Matrix4,r=new P,i=new P;return function o(a,c,u,l,f=null){let d=2*a,h=tt,p=et,x=nt;if(null===f&&(u.boundingBox||u.computeBoundingBox(),r.set(u.boundingBox.min,u.boundingBox.max,l),r.update(),f=r),65535!==p[d+15]){const t=a+8,e=x[a+6];return rt(t,h,C),f.intersectsBox(C)&&o(t,c,u,l,f)?!0:(rt(e,h,C),!(!f.intersectsBox(C)||!o(e,c,u,l,f)))}{const o=c.geometry,r=o.index,f=o.attributes.position,m=u.index,y=u.attributes.position,g=x[a+6],w=p[d+14];if(s.copy(l).invert(),u.boundsTree){rt(a,h,i),i.matrix.copy(s),i.update(),n.geometry=u;const t=u.boundsTree.shapecast(n,(t=>i.intersectsBox(t)),(function(t){t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.update();for(let n=3*g,o=3*(w+g);n<o;n+=3)if(A(e,n,r,f),e.update(),t.intersectsTriangle(e))return!0;return!1}));return n.geometry=null,t}for(let n=3*g,o=w+3*g;n<o;n+=3){A(t,n,r,f),t.a.applyMatrix4(s),t.b.applyMatrix4(s),t.c.applyMatrix4(s),t.update();for(let n=0,o=m.count;n<o;n+=3)if(A(e,n,m,y),e.update(),t.intersectsTriangle(e))return!0}}}}();function $(t,e,n,o){return rt(t,e,C),n.intersectBox(C,o)}const K=[];let Q,tt,et,nt;function ot(t){Q&&K.push(Q),Q=t,tt=new Float32Array(t),et=new Uint16Array(t),nt=new Uint32Array(t)}function st(){Q=null,tt=null,et=null,nt=null,K.length&&ot(K.pop())}function rt(t,e,n){n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5]}const it=Symbol("skip tree generation"),at=new P,ct=new o.Vector3,ut=new T,lt=new o.Vector3,ft=new o.Vector3;class dt{static serialize(t,e,n=!0){function o(t){t.continueGeneration&&t.continueGeneration(),t.count||(o(t.left),o(t.right))}function s(t){return t.count?1:1+s(t.left)+s(t.right)}function r(t,e){const n=t/4,o=t/2,s=!!e.count,u=e.boundingData;for(let t=0;t<6;t++)i[n+t]=u[t];if(s){const s=e.offset,r=e.count;return a[n+6]=s,c[o+14]=r,c[o+15]=65535,t+32}{const o=e.left,s=e.right,i=e.splitAxis;let c;return c=r(t+32,o),a[n+6]=c/4,c=r(c,s),a[n+7]=i,c}}let i,a,c;const u=t._roots;let l;if(t._isPacked)l=u;else{l=[];for(let t=0;t<u.length;t++){const e=u[t];o(e);let n=s(e);const f=new ArrayBuffer(32*n);i=new Float32Array(f),a=new Uint32Array(f),c=new Uint16Array(f),r(0,e),l.push(f)}}const f=e.getIndex();return{roots:l,index:n?f.array.slice():f.array}}static deserialize(t,e,n=!0){const{index:s,roots:r}=t,i=new dt(e,{[it]:!0});if(i._roots=r,i._isPacked=!0,n){const n=e.getIndex();if(null===n){const n=new o.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==s&&(n.array.set(s),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.attributes.position.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");(e=Object.assign({strategy:s,maxDepth:40,maxLeafTris:10,verbose:!0,lazyGeneration:!0,packData:!0,[it]:!1},e)).strategy=Math.max(0,Math.min(2,e.strategy)),this._isPacked=!1,this._roots=null,e[it]||(this._roots=function(t,e){function n(e,o,h,M=null,V=0){if(!A&&V>=w&&(A=!0,b&&(console.warn(`MeshBVH: Max depth of ${w} reached when generating BVH. Consider increasing maxDepth.`),console.warn(this,t))),h<=B||V>=w)return e.offset=o,e.count=h,e;const S=function(t,e,n,o,a,c,u){let l=-1,h=0;if(u===s)l=d(e),-1!==l&&(h=(e[l]+e[l+3])/2);else if(u===r)l=d(t),-1!==l&&(h=function(t,e,n,o){let s=0;for(let r=e,i=e+n;r<i;r++)s+=t[6*r+2*o];return s/n}(n,a,c,l));else if(u===i){const e=3,n=1,s=f(t,x),r=[s.max.x-s.min.x,s.max.y-s.min.y,s.max.z-s.min.z],i=2*(r[0]*r[1]+r[0]*r[2]+r[1]*r[2]),u=[[],[],[]];for(let t=a,e=a+c;t<e;t++)for(let e=0;e<3;e++)u[e].push(o[e][t]);u.forEach((t=>t.sort(((t,e)=>t.p-e.p))));const d=(t,o,s,r,i)=>e+n*(o/t*s+r/t*i);l=-1;let m=n*c;for(let t=0;t<3;t++){const e=(t+1)%3,n=(t+2)%3,o=s.min[p[t]],a=s.max[p[t]],f=u[t];let x=0,y=c;for(let s=0;s<f.length;s++){const c=f[s];x++,y--;const u=c.p-o,p=a-c.p;let g=r[e],w=r[e],b=r[n],B=r[n];const T=d(i,2*(g*b+g*u+b*u),x,2*(w*B+w*p+B*p),y);T<m&&(l=t,h=c.p,m=T)}}}return{axis:l,pos:h}}(e.boundingData,M,c,u,o,h,T);if(-1===S.axis)return e.offset=o,e.count=h,e;const F=function(t,e,n,o,s,r){let i=o,a=o+s-1;const c=r.pos,u=2*r.axis;for(;;){for(;i<=a&&e[6*i+u]<c;)i++;for(;i<=a&&e[6*a+u]>=c;)a--;if(!(i<a))return i;for(let n=0;n<3;n++){let o=t[3*i+n];t[3*i+n]=t[3*a+n],t[3*a+n]=o;let s=e[6*i+2*n+0];e[6*i+2*n+0]=e[6*a+2*n+0],e[6*a+2*n+0]=s;let r=e[6*i+2*n+1];e[6*i+2*n+1]=e[6*a+2*n+1],e[6*a+2*n+1]=r}if(n)for(let t=0;t<3;t++){let e=n[t][i];n[t][i]=n[t][a],n[t][a]=e}i++,a--}}(g,c,u,o,h,S);if(F===o||F===o+h)e.offset=o,e.count=h;else{e.splitAxis=S.axis;const t=new l,s=o,r=F-o;e.left=t,t.boundingData=new Float32Array(6),P?(m(c,s,r,t.boundingData),t.continueGeneration=function(){delete this.continueGeneration,y(c,s,r,a),n(t,s,r,a,V+1)}):(m(c,s,r,t.boundingData,a),n(t,s,r,a,V+1));const i=new l,u=F,f=h-r;e.right=i,i.boundingData=new Float32Array(6),P?(m(c,u,f,i.boundingData),i.continueGeneration=function(){delete this.continueGeneration,y(c,u,f,a),n(i,u,f,a,V+1)}):(m(c,u,f,i.boundingData,a),n(i,u,f,a,V+1))}return e}!function(t){if(!t.index){const e=t.attributes.position.count,n=new(e>65535?Uint32Array:Uint16Array)(e);t.setIndex(new o.BufferAttribute(n,1));for(let t=0;t<e;t++)n[t]=t}}(t);const a=new Float32Array(6),c=function(t){const e=t.attributes.position.array,n=t.index.array,o=n.length/3,s=new Float32Array(6*o);for(let t=0;t<o;t++){const o=3*t,r=6*t,i=3*n[o+0],a=3*n[o+1],c=3*n[o+2];for(let t=0;t<3;t++){const n=e[i+t],o=e[a+t],u=e[c+t];let l=n;o<l&&(l=o),u<l&&(l=u);let f=n;o>f&&(f=o),u>f&&(f=u);const d=(f-l)/2,p=2*t;s[r+p+0]=l+d,s[r+p+1]=d+(Math.abs(l)+d)*h}}return s}(t),u=e.strategy===i?function(t){const e=t.length/6,n=[new Array(e),new Array(e),new Array(e)];for(let o=0;o<e;o++)for(let e=0;e<3;e++)n[e][o]={p:t[6*o+2*e],tri:o};return n}(c):null,g=t.index.array,w=e.maxDepth,b=e.verbose,B=e.maxLeafTris,T=e.strategy,P=e.lazyGeneration;let A=!1;const M=[],V=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const o=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const n=o[t],s=o[t+1];e.push({offset:n/3,count:(s-n)/3})}return e}(t);if(1===V.length){const e=new l,o=V[0];null!=t.boundingBox?(e.boundingData=function(t){const e=new Float32Array(6);return e[0]=t.min.x,e[1]=t.min.y,e[2]=t.min.z,e[3]=t.max.x,e[4]=t.max.y,e[5]=t.max.z,e}(t.boundingBox),y(c,o.offset,o.count,a)):(e.boundingData=new Float32Array(6),m(c,o.offset,o.count,e.boundingData,a)),n(e,o.offset,o.count,a),M.push(e)}else for(let t of V){const e=new l;e.boundingData=new Float32Array(6),m(c,t.offset,t.count,e.boundingData,a),n(e,t.offset,t.count,a),M.push(e)}if(null==t.boundingBox){const e=new o.Box3;t.boundingBox=new o.Box3;for(let n of M)t.boundingBox.union(f(n.boundingData,e))}return M}(t,e),!e.lazyGeneration&&e.packData&&(this._roots=dt.serialize(this,t,!1).roots,this._isPacked=!0))}traverse(t,e=0){if(this._isPacked){const n=this._roots[e],o=new Uint32Array(n),s=new Uint16Array(n);function r(e,i=0){const a=2*e,c=s[a+15];if(c){const r=o[e+6],u=s[a+14];t(i,c,new Float32Array(n,4*e,6),r,u)}else{const s=e+8,a=o[e+6],u=o[e+7];t(i,c,new Float32Array(n,4*e,6),u,!1)||(r(s,i+1),r(a,i+1))}}r(0)}else{function n(e,o=0){const s=!!e.count;s?t(o,s,e.boundingData,e.offset,e.count):t(o,s,e.boundingData,e.splitAxis,!!e.continueGeneration)||(e.left&&n(e.left,o+1),e.right&&n(e.right,o+1))}n(this._roots[e])}}raycast(t,e,n,o){const s=this._isPacked;for(const r of this._roots)s?(ot(r),W(0,t,e,n,o)):N(r,t,e,n,o);s&&st()}raycastFirst(t,e,n){const o=this._isPacked;let s=null;for(const r of this._roots){let i;o?(ot(r),i=Y(0,t,e,n)):i=H(r,t,e,n),null!=i&&(null==s||i.distance<s.distance)&&(s=i)}return o&&st(),s}intersectsGeometry(t,e,n){const o=this._isPacked;let s=!1;for(const r of this._roots)if(o?(ot(r),s=J(0,t,e,n)):s=O(r,t,e,n),s)break;return o&&st(),s}shapecast(t,e,n=null,o=null){const s=this._isPacked;let r=!1;for(const i of this._roots)if(s?(ot(i),r=Z(0,t,e,n,o)):r=X(i,t,e,n,o),r)break;return s&&st(),r}intersectsBox(t,e,n){return at.set(e.min,e.max,n),at.update(),this.shapecast(t,(t=>at.intersectsBox(t)),(t=>at.intersectsTriangle(t)))}intersectsSphere(t,e){return this.shapecast(t,(t=>e.intersectsBox(t)),(t=>t.intersectsSphere(e)))}closestPointToGeometry(t,e,n,o=null,s=null,r=0,i=1/0){e.boundingBox||e.computeBoundingBox(),at.set(e.boundingBox.min,e.boundingBox.max,n),at.update();const a=e.attributes.position,c=e.index;let u=null,l=null;o&&(u=lt),s&&(l=ft);let f=1/0;return this.shapecast(t,((t,e,n)=>n<f&&n<i),(t=>{t.needsUpdate&&t.update();const e=t.sphere;for(let i=0,d=c.count;i<d;i+=3){A(ut,i,c,a),ut.a.applyMatrix4(n),ut.b.applyMatrix4(n),ut.c.applyMatrix4(n),ut.sphere.setFromPoints(ut.points);const d=ut.sphere;if(d.center.distanceTo(e.center)-d.radius-e.radius>f)continue;ut.update();const h=t.distanceToTriangle(ut,u,l);if(h<f&&(o&&o.copy(u),s&&s.copy(l),f=h),h<r)return!0}return!1}),(t=>at.distanceToBox(t,Math.min(f,i)))),f}distanceToGeometry(t,e,n,o,s){return this.closestPointToGeometry(t,e,n,null,null,o,s)}closestPointToPoint(t,e,n,o=0,s=1/0){let r=1/0;return this.shapecast(t,((t,e,n)=>n<r&&n<s),(t=>{t.closestPointToPoint(e,ct);const s=e.distanceTo(ct);return s<r&&(n&&n.copy(ct),r=s),s<o}),(t=>t.distanceToPoint(e))),r}distanceToPoint(t,e,n,o){return this.closestPointToPoint(t,e,null,n,o)}}const ht=new o.LineBasicMaterial({color:65416,transparent:!0,opacity:.3}),pt=(new o.Box3Helper).geometry;let xt=new o.Box3;class mt extends o.Group{constructor(t,e=10,n=0){super("MeshBVHRootVisualizer"),this.depth=e,this._oldDepth=-1,this.mesh=t,this._boundsTree=null,this._group=n,this.update()}update(){this._oldDepth=this.depth,this._boundsTree=this.mesh.geometry.boundsTree;let t=0;for(this._boundsTree&&this._boundsTree.traverse(((e,n,s,r,i)=>{let a=n||i;if(e>=this.depth)return!0;if(e===this.depth-1||a){let e=t<this.children.length?this.children[t]:null;e||(e=new o.LineSegments(pt,ht),e.raycast=()=>[],this.add(e)),t++,f(s,xt),xt.getCenter(e.position),e.scale.subVectors(xt.max,xt.min).multiplyScalar(.5),0===e.scale.x&&(e.scale.x=Number.EPSILON),0===e.scale.y&&(e.scale.y=Number.EPSILON),0===e.scale.z&&(e.scale.z=Number.EPSILON)}}));this.children.length>t;)this.remove(this.children.pop())}}class yt extends o.Group{constructor(t,e=10){super("MeshBVHVisualizer"),this.depth=e,this.mesh=t,this._roots=[],this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let t=0;t<e;t++)if(t>=this._roots.length){const e=new mt(this.mesh,this.depth,t);this.add(e),this._roots.push(e)}else{let e=this._roots[t];e.depth=this.depth,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new yt(this.mesh,this.depth)}}const gt=yt;function wt(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function bt(t){return t._roots.map(((e,n)=>function(t,e){const n={total:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0]};return t.traverse(((t,e,o,s,r)=>{n.total++,e?(n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(r,n.tris.min),n.tris.max=Math.max(r,n.tris.max)):n.splits[s]++}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function Bt(t){const e=new Set,n=[t];let o=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;o+=wt(e);const s=t[e];!s||"object"!=typeof s&&"function"!=typeof s?o+=wt(s):/(Uint|Int|Float)(8|16|32)Array/.test(s.constructor.name)||s instanceof ArrayBuffer?o+=s.byteLength:n.push(s)}}}return o}const Tt=new o.Box3,Pt=new o.Box3,At=new o.Vector3;class Mt{constructor(t,e){this.bvh=t,this.geometry=e}getJSONStructure(){const{bvh:t}=this,e=[];return t.traverse(((t,n,s,r,i)=>{const a={bounds:f(s,new o.Box3)};n?(a.count=i,a.offset=r):(a.left=null,a.right=null),e[t]=a;const c=e[t-1];c&&(null===c.left?c.left=a:c.right=a)})),e[0]}validateBounds(){const{bvh:t,geometry:e}=this,n=[],o=e.index,s=e.getAttribute("position");let r=!0;return t.traverse(((t,e,i,a,c)=>{const u={depth:t,isLeaf:e,boundingData:i,offset:a,count:c};n[t]=u,f(i,Tt);const l=n[t-1];if(e)for(let t=3*a,e=3*(a+c);t<e;t+=3){const e=o.getX(t),n=o.getX(t+1),i=o.getX(t+2);let a;At.fromBufferAttribute(s,e),a=Tt.containsPoint(At),At.fromBufferAttribute(s,n),a=a&&Tt.containsPoint(At),At.fromBufferAttribute(s,i),a=a&&Tt.containsPoint(At),console.assert(a,"Leaf bounds does not fully contain triangle."),r=r&&a}if(l){f(i,Pt);const t=Pt.containsBox(Tt);console.assert(t,"Parent bounds does not fully contain child."),r=r&&t}})),r}}const Vt=new o.Ray,St=new o.Matrix4,Ft=o.Mesh.prototype.raycast;function zt(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;if(St.copy(this.matrixWorld).invert(),Vt.copy(t.ray).applyMatrix4(St),!0===t.firstHitOnly){const n=this.geometry.boundsTree.raycastFirst(this,t,Vt);n&&e.push(n)}else this.geometry.boundsTree.raycast(this,t,Vt,e)}else Ft.call(this,t,e)}function Dt(t){return this.boundsTree=new dt(this,t),this.boundsTree}function vt(){this.boundsTree=null}}}]);